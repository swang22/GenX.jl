@doc raw"""
write_water_bypass(path::AbstractString, inputs::Dict, setup::Dict, EP::Model)

Function for writing the different values of water generated by the different hydro technologies in operation.
"""
function write_water_bypass(path::AbstractString, inputs::Dict, setup::Dict, EP::Model)
	dfGen = inputs["dfGen"]
	G = inputs["G"]     # Number of resources (generators, storage, DR, and DERs)
	T = inputs["T"]     # Number of time steps (hours)
	WD_All = inputs["HYDRO_WD"]
	# Water discharged for electricity by each resource in each time step
	dfHydroPower = DataFrame(Resource = inputs["RESOURCES"], Zone = dfGen[!,:Zone], AnnualSum = Array{Union{Missing,Float64}}(undef, G))
	w_bypass = zeros(G,T)
	if setup["ParameterScale"] == 1
		w_bypass *= ModelScalingFactor
	end
	scale_factor = setup["ParameterScale"] == 1 ? ModelScalingFactor : 1
	if !isempty(WD_All)
	    w_bypass[WD_All, :] = value.(EP[:vW_BYPASS][WD_All, :]) * scale_factor
	end
	dfHydroPower.AnnualSum .= w_bypass * inputs["omega"]
	dfHydroPower = hcat(dfHydroPower, DataFrame(w_bypass, :auto))

	auxNew_Names=[Symbol("Resource");Symbol("Zone");Symbol("AnnualSum");[Symbol("t$t") for t in 1:T]]
	rename!(dfHydroPower,auxNew_Names)

	total = DataFrame(["Total" 0 sum(dfHydroPower[!,:AnnualSum]) fill(0.0, (1,T))], :auto)
	total[:, 4:T+3] .= sum(w_bypass, dims = 1)

	rename!(total,auxNew_Names)
	dfHydroPower = vcat(dfHydroPower, total)
	CSV.write(joinpath(path, "water_bypass.csv"), dftranspose(dfHydroPower, false), writeheader=false)
	return dfHydroPower
end
